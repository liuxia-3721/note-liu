<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        div{
            width: 20px;
            height: 20px;
            background: #00f;
            border-radius: 50%;
            position: absolute;
        }
    </style>
</head>
<body>
    
</body>
<!-- <script src="../js工具箱/move匀速包装.js"></script> -->
<script>


// 原工厂模式
// function people(name,age){
//     var obj={};
//     obj.name=name;
//     obj.age=age;
//     obj.say=function(){
//         console.log(this.name+"---"+this.age)
//     }
//     return obj
// }
// var p1=people("张三",11);
// p1.say()
// var p2=people("李四",22)
// p2.say()

// // 构造函数模式（新工厂模式）
// function People(name,age){
//     this.name=name;
//     this.age=age;
//     this.say=function(){        
//         console.log("大家好，我是"+this.name)
//     }
// }
// var p1=new People("张三",23);
// var p2=new People("李四",22);
// console.log(p1.say==p2.sya)  // false  每次都会继承一个新的函数

// // 原型对象模式
// function People(name,age){
//     this.name=name;
//     this.age=age;
// }
// People.prototype.say=function(){
//     console.log(this.name)
// }
// var p1=new People("刘恒",24);
// var p2=new People("刘永伟",24);
// console.log(p1.say==p2.say) //true 共用父级的函数
// console.log(p2.say)

// var arr=[11,23,1,33,4,5];
// for(var i=0;i<arr.length-1;i++){
//     for(var j=0;j<arr.length-1-i;j++){
//         if(arr[j]>arr[j+1]){
//             var ls=arr[j];
//             arr[j]=arr[j+1];
//             arr[j+1]=ls;
//         }
//     }
// }
// console.log(arr)

// function fn(){
//     var i=10;
//     return function(){
//         i++;
//         return i;
//     }
// }
// var func=fn();
// console.log(func());
// console.log(func());
// console.log(func());
var obj={name:"root",pass:123};
for(var i in obj){
    console.log(typeof i)
}
// console.log(obj["name"])

</script>
</html>